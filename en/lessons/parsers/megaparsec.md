---
version: 1.0.0
title: Megaparsec
---

{% include toc.html %}

[Megaparsec](https://hackage.haskell.org/package/megaparsec) is the direct fork of *Parsec*.

We'll see what changed and what are the impacts.

# Definition

*Megaparsec* also has a type named `ParsecT`, but it's definition changed a bit from *Parsec*:

```haskell
-- | @'ParsecT' e s m a@ is a parser with custom data component of error
-- @e@, stream type @s@, underlying monad @m@ and return type @a@.
newtype ParsecT e s m a = ParsecT
  { unParser ::
      forall b.
      State s e ->
      (a -> State s e -> Hints (Token s) -> m b) -> -- consumed-OK
      (ParseError s e -> State s e -> m b) -> -- consumed-error
      (a -> State s e -> Hints (Token s) -> m b) -> -- empty-OK
      (ParseError s e -> State s e -> m b) -> -- empty-error
      m b
  }
```

We can see three big changes:

 * The user state has been dropped (we can guess that it should be part of `m` if we want to have one)
 * `ParseError` has been parameterize (and the error type too)
 * A `Hints` type was introduced over `Token`, which is an associated type over `Stream`

We can start enquireing about `Hints`:

```haskell
-- | 'Hints' represent a collection of 'ErrorItem's to be included into
-- 'ParseError' (when it's a 'TrivialError') as “expected” message items
-- when a parser fails without consuming input right after successful parser
-- that produced the hints.
--
-- For example, without hints you could get:
--
-- >>> parseTest (many (char 'r') <* eof) "ra"
-- 1:2:
-- unexpected 'a'
-- expecting end of input
--
-- We're getting better error messages with the help of hints:
--
-- >>> parseTest (many (char 'r') <* eof) "ra"
-- 1:2:
-- unexpected 'a'
-- expecting 'r' or end of input
newtype Hints t = Hints [Set (ErrorItem t)]
```

Very interesting, that's another reason to have a look at `ParseError`:

```haskell
data ParseError s e
  = -- | Trivial errors, generated by the Megaparsec's machinery. The data
    -- constructor includes the offset of error, unexpected token (if any),
    -- and expected tokens.
    TrivialError Int (Maybe (ErrorItem (Token s))) (Set (ErrorItem (Token s)))
  | -- | Fancy, custom errors.
    FancyError Int (Set (ErrorFancy e))
```

There's clearly an emphasis on error handling.

Even `State` is parameterizing with the error type:

```haskell
data State s e = State
  { -- | The rest of input to process
    stateInput :: s,
    -- | Number of processed tokens so far
    stateOffset :: !Int,
    -- | State that is used for line\/column calculation
    statePosState :: PosState s,
    -- | Collection of “delayed” 'ParseError's in reverse order. This means
    -- that the last registered error is the first element of the list.
    stateParseErrors :: [ParseError s e]
  }
  deriving (Typeable, Generic)

-- | A special kind of state that is used to calculate line\/column
-- positions on demand.
--
data PosState s = PosState
  { -- | The rest of input to process
    pstateInput :: s,
    -- | Offset corresponding to beginning of 'pstateInput'
    pstateOffset :: !Int,
    -- | Source position corresponding to beginning of 'pstateInput'
    pstateSourcePos :: !SourcePos,
    -- | Tab width to use for column calculation
    pstateTabWidth :: Pos,
    -- | Prefix to prepend to offending line
    pstateLinePrefix :: String
  }
```

Ok, I'm not sure why there's `stateInput` and `pstateInput`.

let see how there're used is the code:

```haskell
initialState :: String -> s -> State s e
initialState name s =
  State
    { stateInput = s,
      stateOffset = 0,
      statePosState =
        PosState
          { pstateInput = s,
            pstateOffset = 0,
            pstateSourcePos = initialPos name,
            pstateTabWidth = defaultTabWidth,
            pstateLinePrefix = ""
          },
      stateParseErrors = []
    }
```

No surprise here, at initialization they point out to the value.

Next one:

```haskell
-- | Return the current input.
getInput :: MonadParsec e s m => m s
getInput = stateInput <$> getParserState

-- | @'setInput' input@ continues parsing with @input@.
setInput :: MonadParsec e s m => s -> m ()
setInput s = updateParserState (\(State _ o pst de) -> State s o pst de)
```

Like in `Parsec`, `stateInput` holds the current position.

Then, the only other mention of `pstateInput` or `stateInput` is:

```haskell
-- | A helper definition to facilitate defining 'reachOffset' for various
-- stream types.
reachOffset' ::
  forall s.
  Stream s =>
  -- | How to split input stream at given offset
  (Int -> s -> (Tokens s, s)) ->
  -- | How to fold over input stream
  (forall b. (b -> Token s -> b) -> b -> Tokens s -> b) ->
  -- | How to convert chunk of input stream into a 'String'
  (Tokens s -> String) ->
  -- | How to convert a token into a 'Char'
  (Token s -> Char) ->
  -- | Newline token and tab token
  (Token s, Token s) ->
  -- | Offset to reach
  Int ->
  -- | Initial 'PosState' to use
  PosState s ->
  -- | Line at which 'SourcePos' is located, updated 'PosState'
  (Maybe String, PosState s)
reachOffset'
  splitAt'
  foldl''
  fromToks
  fromTok
  (newlineTok, tabTok)
  o
  PosState {..} =
    ( Just $ case expandTab pstateTabWidth
        . addPrefix
        . f
        . fromToks
        . fst
        $ takeWhile_ (/= newlineTok) post of
        "" -> "<empty line>"
        xs -> xs,
      PosState
        { pstateInput = post,
          pstateOffset = max pstateOffset o,
          pstateSourcePos = spos,
          pstateTabWidth = pstateTabWidth,
          pstateLinePrefix =
            if sameLine
              then -- NOTE We don't use difference lists here because it's
              -- desirable for 'PosState' to be an instance of 'Eq' and
              -- 'Show'. So we just do appending here. Fortunately several
              -- parse errors on the same line should be relatively rare.
                pstateLinePrefix ++ f ""
              else f ""
        }
    )
    where
      addPrefix xs =
        if sameLine
          then pstateLinePrefix ++ xs
          else xs
      sameLine = sourceLine spos == sourceLine pstateSourcePos
      (pre, post) = splitAt' (o - pstateOffset) pstateInput
      St spos f = foldl'' go (St pstateSourcePos id) pre
      go (St apos g) ch =
        let SourcePos n l c = apos
            c' = unPos c
            w = unPos pstateTabWidth
         in if
                | ch == newlineTok ->
                    St
                      (SourcePos n (l <> pos1) pos1)
                      id
                | ch == tabTok ->
                    St
                      (SourcePos n l (mkPos $ c' + w - ((c' - 1) `rem` w)))
                      (g . (fromTok ch :))
                | otherwise ->
                    St
                      (SourcePos n l (c <> pos1))
                      (g . (fromTok ch :))
```

Let's see what is reachOffset is used for:

```haskell
-- | Type class for inputs that can also be used for error reporting.
--
-- @since 9.0.0
class Stream s => TraversableStream s where
  {-# MINIMAL reachOffset | reachOffsetNoLine #-}

  -- | Given an offset @o@ and initial 'PosState', adjust the state in such
  -- a way that it starts at the offset.
  --
  -- Return two values (in order):
  --
  --     * 'Maybe' 'String' representing the line on which the given offset
  --       @o@ is located. It can be omitted (i.e. 'Nothing'); in that case
  --       error reporting functions will not show offending lines. If
  --       returned, the line should satisfy a number of conditions that are
  --       described below.
  --     * The updated 'PosState' which can be in turn used to locate
  --       another offset @o'@ given that @o' >= o@.
  --
  -- The 'String' representing the offending line in input stream should
  -- satisfy the following:
  --
  --     * It should adequately represent location of token at the offset of
  --       interest, that is, character at 'sourceColumn' of the returned
  --       'SourcePos' should correspond to the token at the offset @o@.
  --     * It should not include the newline at the end.
  --     * It should not be empty, if the line happens to be empty, it
  --       should be replaced with the string @\"\<empty line\>\"@.
  --     * Tab characters should be replaced by appropriate number of
  --       spaces, which is determined by the 'pstateTabWidth' field of
  --       'PosState'.
  --
  -- __Note__: type signature of the function was changed in the version
  -- /9.0.0/.
  --
  -- @since 7.0.0
  reachOffset ::
    -- | Offset to reach
    Int ->
    -- | Initial 'PosState' to use
    PosState s ->
    -- | See the description of the function
    (Maybe String, PosState s)
```

Ok, `reachOffset` is a way to update `PosState`, let's how it's used:

```haskell
-- | Return the current source position. This function /is not cheap/, do
-- not call it e.g. on matching of every token, that's a bad idea. Still you
-- can use it to get 'SourcePos' to attach to things that you parse.
--
-- The function works under the assumption that we move in the input stream
-- only forwards and never backwards, which is always true unless the user
-- abuses the library.
--
-- @since 7.0.0
getSourcePos :: (TraversableStream s, MonadParsec e s m) => m SourcePos
getSourcePos = do
  st <- getParserState
  let pst = reachOffsetNoLine (stateOffset st) (statePosState st)
  setParserState st {statePosState = pst}
  return (pstateSourcePos pst)

-- | Pretty-print a 'ParseErrorBundle'. All 'ParseError's in the bundle will
-- be pretty-printed in order together with the corresponding offending
-- lines by doing a single pass over the input stream. The rendered 'String'
-- always ends with a newline.
--
-- @since 7.0.0
errorBundlePretty ::
  forall s e.
  ( VisualStream s,
    TraversableStream s,
    ShowErrorComponent e
  ) =>
  -- | Parse error bundle to display
  ParseErrorBundle s e ->
  -- | Textual rendition of the bundle
  String
errorBundlePretty ParseErrorBundle {..} = ...
```

So it's only used for debugging purposes.

While `stateInput` is used in base functions:

```haskell
pToken ::
  forall e s m a.
  Stream s =>
  (Token s -> Maybe a) ->
  Set (ErrorItem (Token s)) ->
  ParsecT e s m a
pToken test ps = ParsecT $ \s@(State input o pst de) cok _ _ eerr ->
  case take1_ input of
    Nothing ->
      let us = pure EndOfInput
       in eerr (TrivialError o us ps) s
    Just (c, cs) ->
      case test c of
        Nothing ->
          let us = (Just . Tokens . nes) c
           in eerr
                (TrivialError o us ps)
                (State input o pst de)
        Just x ->
          cok x (State cs (o + 1) pst de) mempty
```

# Conclusion

While `Megaparsec` is a fork of `Parsec`, it diverged somehow:

 * It uses more structures underneath
 * There's a more detailed structure for error handling
